// File: Dispatch/Handlers/BasicAttackMessageHandler.cpp (Refactored)
#include <RiftForged/Handlers/BasicAttackMessageHandler/BasicAttackMessageHandler.h>
// Game Logic & Engine systems we interact with
#include <RiftForged/GameLogic/PlayerManager/PlayerManager.h>
#include <RiftForged/GameEngine/GameEngine/GameEngine.h> // Assuming this provides GameplayEngine

// Utilities
#include <RiftForged/Utilities/Logger/Logger.h>

// Standard library for safe variant access
#include <variant>

namespace RiftForged {
    namespace Dispatch {

        // The constructor remains unchanged.
        BasicAttackMessageHandler::BasicAttackMessageHandler(
            RiftForged::GameLogic::PlayerManager& playerManager,
            RiftForged::Gameplay::GameplayEngine& gameplayEngine,
            RiftForged::Utilities::Threading::TaskThreadPool* taskPool)
            : m_playerManager(playerManager),
            m_gameplayEngine(gameplayEngine),
            m_taskThreadPool(taskPool)
        {
            RF_NETWORK_INFO("BasicAttackMessageHandler: Constructed.");
        }

        /**
         * @brief Processes a fully-formed, decoupled GameCommand.
         * This method's only job is to validate the command, find the correct player,
         * and pass the clean data to the GameplayEngine.
         */
        void BasicAttackMessageHandler::Process(const RiftForged::GameLogic::Commands::GameCommand& command) {

            // Step 1: Safely get the specific command data from the variant.
            // This ensures we're actually processing a basic attack command.
            const auto* attackData = std::get_if<RiftForged::GameLogic::Commands::BasicAttackIntent>(&command.data);
            if (!attackData) {
                RF_NETWORK_ERROR("BasicAttackMessageHandler: Received wrong command type for PlayerID {}!", command.originatingPlayerID);
                return;
            }

            // Step 2: Use the clean PlayerID from the command to find the player object.
            auto* attacker = m_playerManager.FindPlayer(command.originatingPlayerID);
            if (!attacker) {
                RF_NETWORK_WARN("BasicAttackMessageHandler: Null attacker pointer for PlayerID {}. Discarding.", command.originatingPlayerID);
                return;
            }

            RF_NETWORK_DEBUG("Player {} sent BasicAttackIntent. Aim: ({:.1f},{:.1f},{:.1f}), TargetID: {}",
                attacker->playerId,
                attackData->aimDirection.x,
                attackData->aimDirection.y,
                attackData->aimDirection.z,
                attackData->targetEntityId);

            // Step 3: Execute the attack in the GameplayEngine using the pure data.
            // The handler's primary responsibility is fulfilled here.
            // Note that we no longer capture the 'AttackOutcome'. The GameplayEngine will now
            // be responsible for handling its own outcomes.
            m_gameplayEngine.ExecuteBasicAttack(
                attacker,
                attackData->aimDirection,
                attackData->targetEntityId
            );

            // THAT'S IT! The handler's job is done.
            //
            // All logic for creating S2C_Response, building FlatBuffers, and returning
            // messages has been REMOVED. This logic will be handled by our new S2C
            // Response System in Phase 2, which will listen for events generated by
            // the GameplayEngine as a result of this ExecuteBasicAttack call.
        }

    } // namespace Dispatch
} // namespace RiftForged