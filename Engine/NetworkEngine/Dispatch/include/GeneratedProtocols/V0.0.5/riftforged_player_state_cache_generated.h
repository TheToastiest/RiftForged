// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RIFTFORGEDPLAYERSTATECACHE_RIFTFORGED_CACHE_H_
#define FLATBUFFERS_GENERATED_RIFTFORGEDPLAYERSTATECACHE_RIFTFORGED_CACHE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

#include "riftforged_common_types_generated.h"

namespace RiftForged {
namespace Cache {

struct PlayerStateCache;
struct PlayerStateCacheBuilder;
struct PlayerStateCacheT;

struct PlayerStateCacheT : public ::flatbuffers::NativeTable {
  typedef PlayerStateCache TableType;
  uint64_t player_id = 0;
  std::unique_ptr<RiftForged::Networking::Shared::Vec3> position{};
  std::unique_ptr<RiftForged::Networking::Shared::Quaternion> orientation{};
  std::unique_ptr<RiftForged::Networking::Shared::Vec3> velocity{};
  int32_t current_health = 0;
  int32_t max_health = 0;
  std::vector<RiftForged::Networking::Shared::StatusEffectCategory> active_status_effects{};
  uint16_t current_zone_id = 0;
  PlayerStateCacheT() = default;
  PlayerStateCacheT(const PlayerStateCacheT &o);
  PlayerStateCacheT(PlayerStateCacheT&&) FLATBUFFERS_NOEXCEPT = default;
  PlayerStateCacheT &operator=(PlayerStateCacheT o) FLATBUFFERS_NOEXCEPT;
};

struct PlayerStateCache FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayerStateCacheT NativeTableType;
  typedef PlayerStateCacheBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAYER_ID = 4,
    VT_POSITION = 6,
    VT_ORIENTATION = 8,
    VT_VELOCITY = 10,
    VT_CURRENT_HEALTH = 12,
    VT_MAX_HEALTH = 14,
    VT_ACTIVE_STATUS_EFFECTS = 16,
    VT_CURRENT_ZONE_ID = 20
  };
  uint64_t player_id() const {
    return GetField<uint64_t>(VT_PLAYER_ID, 0);
  }
  bool KeyCompareLessThan(const PlayerStateCache * const o) const {
    return player_id() < o->player_id();
  }
  int KeyCompareWithValue(uint64_t _player_id) const {
    return static_cast<int>(player_id() > _player_id) - static_cast<int>(player_id() < _player_id);
  }
  const RiftForged::Networking::Shared::Vec3 *position() const {
    return GetStruct<const RiftForged::Networking::Shared::Vec3 *>(VT_POSITION);
  }
  const RiftForged::Networking::Shared::Quaternion *orientation() const {
    return GetStruct<const RiftForged::Networking::Shared::Quaternion *>(VT_ORIENTATION);
  }
  const RiftForged::Networking::Shared::Vec3 *velocity() const {
    return GetStruct<const RiftForged::Networking::Shared::Vec3 *>(VT_VELOCITY);
  }
  int32_t current_health() const {
    return GetField<int32_t>(VT_CURRENT_HEALTH, 0);
  }
  int32_t max_health() const {
    return GetField<int32_t>(VT_MAX_HEALTH, 0);
  }
  const ::flatbuffers::Vector<uint32_t> *active_status_effects() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_ACTIVE_STATUS_EFFECTS);
  }
  uint16_t current_zone_id() const {
    return GetField<uint16_t>(VT_CURRENT_ZONE_ID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_PLAYER_ID, 8) &&
           VerifyField<RiftForged::Networking::Shared::Vec3>(verifier, VT_POSITION, 4) &&
           VerifyField<RiftForged::Networking::Shared::Quaternion>(verifier, VT_ORIENTATION, 4) &&
           VerifyField<RiftForged::Networking::Shared::Vec3>(verifier, VT_VELOCITY, 4) &&
           VerifyField<int32_t>(verifier, VT_CURRENT_HEALTH, 4) &&
           VerifyField<int32_t>(verifier, VT_MAX_HEALTH, 4) &&
           VerifyOffset(verifier, VT_ACTIVE_STATUS_EFFECTS) &&
           verifier.VerifyVector(active_status_effects()) &&
           VerifyField<uint16_t>(verifier, VT_CURRENT_ZONE_ID, 2) &&
           verifier.EndTable();
  }
  PlayerStateCacheT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PlayerStateCacheT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<PlayerStateCache> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PlayerStateCacheT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PlayerStateCacheBuilder {
  typedef PlayerStateCache Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_player_id(uint64_t player_id) {
    fbb_.AddElement<uint64_t>(PlayerStateCache::VT_PLAYER_ID, player_id, 0);
  }
  void add_position(const RiftForged::Networking::Shared::Vec3 *position) {
    fbb_.AddStruct(PlayerStateCache::VT_POSITION, position);
  }
  void add_orientation(const RiftForged::Networking::Shared::Quaternion *orientation) {
    fbb_.AddStruct(PlayerStateCache::VT_ORIENTATION, orientation);
  }
  void add_velocity(const RiftForged::Networking::Shared::Vec3 *velocity) {
    fbb_.AddStruct(PlayerStateCache::VT_VELOCITY, velocity);
  }
  void add_current_health(int32_t current_health) {
    fbb_.AddElement<int32_t>(PlayerStateCache::VT_CURRENT_HEALTH, current_health, 0);
  }
  void add_max_health(int32_t max_health) {
    fbb_.AddElement<int32_t>(PlayerStateCache::VT_MAX_HEALTH, max_health, 0);
  }
  void add_active_status_effects(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> active_status_effects) {
    fbb_.AddOffset(PlayerStateCache::VT_ACTIVE_STATUS_EFFECTS, active_status_effects);
  }
  void add_current_zone_id(uint16_t current_zone_id) {
    fbb_.AddElement<uint16_t>(PlayerStateCache::VT_CURRENT_ZONE_ID, current_zone_id, 0);
  }
  explicit PlayerStateCacheBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlayerStateCache> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlayerStateCache>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PlayerStateCache> CreatePlayerStateCache(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t player_id = 0,
    const RiftForged::Networking::Shared::Vec3 *position = nullptr,
    const RiftForged::Networking::Shared::Quaternion *orientation = nullptr,
    const RiftForged::Networking::Shared::Vec3 *velocity = nullptr,
    int32_t current_health = 0,
    int32_t max_health = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> active_status_effects = 0,
    uint16_t current_zone_id = 0) {
  PlayerStateCacheBuilder builder_(_fbb);
  builder_.add_player_id(player_id);
  builder_.add_active_status_effects(active_status_effects);
  builder_.add_max_health(max_health);
  builder_.add_current_health(current_health);
  builder_.add_velocity(velocity);
  builder_.add_orientation(orientation);
  builder_.add_position(position);
  builder_.add_current_zone_id(current_zone_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PlayerStateCache> CreatePlayerStateCacheDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t player_id = 0,
    const RiftForged::Networking::Shared::Vec3 *position = nullptr,
    const RiftForged::Networking::Shared::Quaternion *orientation = nullptr,
    const RiftForged::Networking::Shared::Vec3 *velocity = nullptr,
    int32_t current_health = 0,
    int32_t max_health = 0,
    const std::vector<uint32_t> *active_status_effects = nullptr,
    uint16_t current_zone_id = 0) {
  auto active_status_effects__ = active_status_effects ? _fbb.CreateVector<uint32_t>(*active_status_effects) : 0;
  return RiftForged::Cache::CreatePlayerStateCache(
      _fbb,
      player_id,
      position,
      orientation,
      velocity,
      current_health,
      max_health,
      active_status_effects__,
      current_zone_id);
}

::flatbuffers::Offset<PlayerStateCache> CreatePlayerStateCache(::flatbuffers::FlatBufferBuilder &_fbb, const PlayerStateCacheT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline PlayerStateCacheT::PlayerStateCacheT(const PlayerStateCacheT &o)
      : player_id(o.player_id),
        position((o.position) ? new RiftForged::Networking::Shared::Vec3(*o.position) : nullptr),
        orientation((o.orientation) ? new RiftForged::Networking::Shared::Quaternion(*o.orientation) : nullptr),
        velocity((o.velocity) ? new RiftForged::Networking::Shared::Vec3(*o.velocity) : nullptr),
        current_health(o.current_health),
        max_health(o.max_health),
        active_status_effects(o.active_status_effects),
        current_zone_id(o.current_zone_id) {
}

inline PlayerStateCacheT &PlayerStateCacheT::operator=(PlayerStateCacheT o) FLATBUFFERS_NOEXCEPT {
  std::swap(player_id, o.player_id);
  std::swap(position, o.position);
  std::swap(orientation, o.orientation);
  std::swap(velocity, o.velocity);
  std::swap(current_health, o.current_health);
  std::swap(max_health, o.max_health);
  std::swap(active_status_effects, o.active_status_effects);
  std::swap(current_zone_id, o.current_zone_id);
  return *this;
}

inline PlayerStateCacheT *PlayerStateCache::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PlayerStateCacheT>(new PlayerStateCacheT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PlayerStateCache::UnPackTo(PlayerStateCacheT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = player_id(); _o->player_id = _e; }
  { auto _e = position(); if (_e) _o->position = std::unique_ptr<RiftForged::Networking::Shared::Vec3>(new RiftForged::Networking::Shared::Vec3(*_e)); }
  { auto _e = orientation(); if (_e) _o->orientation = std::unique_ptr<RiftForged::Networking::Shared::Quaternion>(new RiftForged::Networking::Shared::Quaternion(*_e)); }
  { auto _e = velocity(); if (_e) _o->velocity = std::unique_ptr<RiftForged::Networking::Shared::Vec3>(new RiftForged::Networking::Shared::Vec3(*_e)); }
  { auto _e = current_health(); _o->current_health = _e; }
  { auto _e = max_health(); _o->max_health = _e; }
  { auto _e = active_status_effects(); if (_e) { _o->active_status_effects.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->active_status_effects[_i] = static_cast<RiftForged::Networking::Shared::StatusEffectCategory>(_e->Get(_i)); } } else { _o->active_status_effects.resize(0); } }
  { auto _e = current_zone_id(); _o->current_zone_id = _e; }
}

inline ::flatbuffers::Offset<PlayerStateCache> PlayerStateCache::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PlayerStateCacheT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePlayerStateCache(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<PlayerStateCache> CreatePlayerStateCache(::flatbuffers::FlatBufferBuilder &_fbb, const PlayerStateCacheT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PlayerStateCacheT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _player_id = _o->player_id;
  auto _position = _o->position ? _o->position.get() : nullptr;
  auto _orientation = _o->orientation ? _o->orientation.get() : nullptr;
  auto _velocity = _o->velocity ? _o->velocity.get() : nullptr;
  auto _current_health = _o->current_health;
  auto _max_health = _o->max_health;
  auto _active_status_effects = _o->active_status_effects.size() ? _fbb.CreateVectorScalarCast<uint32_t>(::flatbuffers::data(_o->active_status_effects), _o->active_status_effects.size()) : 0;
  auto _current_zone_id = _o->current_zone_id;
  return RiftForged::Cache::CreatePlayerStateCache(
      _fbb,
      _player_id,
      _position,
      _orientation,
      _velocity,
      _current_health,
      _max_health,
      _active_status_effects,
      _current_zone_id);
}

inline const RiftForged::Cache::PlayerStateCache *GetPlayerStateCache(const void *buf) {
  return ::flatbuffers::GetRoot<RiftForged::Cache::PlayerStateCache>(buf);
}

inline const RiftForged::Cache::PlayerStateCache *GetSizePrefixedPlayerStateCache(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<RiftForged::Cache::PlayerStateCache>(buf);
}

inline bool VerifyPlayerStateCacheBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<RiftForged::Cache::PlayerStateCache>(nullptr);
}

inline bool VerifySizePrefixedPlayerStateCacheBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<RiftForged::Cache::PlayerStateCache>(nullptr);
}

inline void FinishPlayerStateCacheBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<RiftForged::Cache::PlayerStateCache> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedPlayerStateCacheBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<RiftForged::Cache::PlayerStateCache> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<RiftForged::Cache::PlayerStateCacheT> UnPackPlayerStateCache(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<RiftForged::Cache::PlayerStateCacheT>(GetPlayerStateCache(buf)->UnPack(res));
}

inline std::unique_ptr<RiftForged::Cache::PlayerStateCacheT> UnPackSizePrefixedPlayerStateCache(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<RiftForged::Cache::PlayerStateCacheT>(GetSizePrefixedPlayerStateCache(buf)->UnPack(res));
}

}  // namespace Cache
}  // namespace RiftForged

#endif  // FLATBUFFERS_GENERATED_RIFTFORGEDPLAYERSTATECACHE_RIFTFORGED_CACHE_H_
